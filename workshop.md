แผนการจัดเวิร์คชอป: การสร้างแอปพลิเคชัน Todo ด้วย NestJS ที่ทดสอบได้ง่าย พร้อมความยืดหยุ่นในการจัดการฐานข้อมูลส่วนที่ 1: พื้นฐานของ NestJSโมดูลที่ 1: ความรู้เบื้องต้นเกี่ยวกับ NestJS1.1. NestJS คืออะไร? ปรัชญาหลัก ประโยชน์ และระบบนิเวศNestJS เป็นเฟรมเวิร์ก Node.js แบบก้าวหน้า (progressive) สำหรับการสร้างแอปพลิเคชันฝั่งเซิร์ฟเวอร์ที่มีประสิทธิภาพ เชื่อถือได้ และสามารถขยายขนาดได้ โดยเน้นการใช้ JavaScript/TypeScript ที่ทันสมัย ประโยชน์หลักของ NestJS ประกอบด้วย:
ความสามารถในการขยายขนาดและการบำรุงรักษา (Scalability & Maintainability): επιτυγχάνεταιผ่านสถาปัตยกรรมแบบโมดูลาร์และโครงสร้างโค้ดที่เป็นระเบียบ
ผลิตภาพ (Productivity): เพิ่มขึ้นด้วย TypeScript, เครื่องมือ CLI และชุดคุณสมบัติที่หลากหลาย
ความคุ้นเคย (Familiarity): ได้รับแรงบันดาลใจจาก Angular ทำให้ง่ายสำหรับนักพัฒนาที่มีประสบการณ์กับ Angular
ความสามารถในการทดสอบ (Testability): มีการสนับสนุนในตัวสำหรับการทำ Dependency Injection และเครื่องมือช่วยทดสอบ
ระบบนิเวศที่สมบูรณ์ (Rich Ecosystem): มีเครื่องมือและการผสานรวมที่หลากหลาย
สถาปัตยกรรมของ NestJS ผสมผสานองค์ประกอบของการเขียนโปรแกรมเชิงวัตถุ (OOP), การเขียนโปรแกรมเชิงฟังก์ชัน (FP) และการเขียนโปรแกรมเชิงฟังก์ชันแบบรีแอกทีฟ (FRP) โดยพื้นฐานแล้ว NestJS สร้างขึ้นบน Express.js แต่สามารถกำหนดค่าให้ใช้กับ Fastify ได้เช่นกันลักษณะ "ก้าวหน้า" (progressive) ของ NestJS ไม่ได้หมายถึงเพียงแค่การใช้คุณสมบัติใหม่ๆ ของ JavaScript เท่านั้น แต่ยังเกี่ยวกับการนำหลักการทางวิศวกรรมซอฟต์แวร์ที่ได้รับการยอมรับ (เช่น Dependency Injection, modularity จากเฟรมเวิร์กอย่าง Angular/Spring) มาสู่โลกของ Node.js ซึ่งในอดีตมักจะไม่มีข้อกำหนดที่ชัดเจนมากนัก Node.js โดยเฉพาะเมื่อใช้กับ Express ให้อิสระในการพัฒนาค่อนข้างสูง ซึ่งเป็นข้อดีสำหรับโปรเจกต์ขนาดเล็ก แต่อาจนำไปสู่สถาปัตยกรรมที่ไม่สอดคล้องกันในโปรเจกต์ขนาดใหญ่ เฟรมเวิร์กเช่น Angular (สำหรับ frontend) และ Spring (สำหรับ Java backend) ได้ส่งเสริมแนวทางการพัฒนาที่มีโครงสร้างมาเป็นเวลานาน NestJS เข้ามาเติมเต็มช่องว่างนี้โดยการนำเสนอแนวทางที่มีโครงสร้างและมีข้อกำหนดที่ชัดเจน (แต่ยังคงความยืดหยุ่น) สำหรับการพัฒนา backend ด้วย Node.js โดยใช้ประโยชน์จาก TypeScript เพื่อเพิ่มความแข็งแกร่ง สิ่งนี้ทำให้ NestJS "ก้าวหน้า" เพราะเป็นการยกระดับมาตรฐานทางสถาปัตยกรรมสำหรับการพัฒนาแอปพลิเคชันฝั่งเซิร์ฟเวอร์ด้วย Node.jsการผสมผสานระหว่าง TypeScript และสถาปัตยกรรมแบบโมดูลาร์ที่ใช้ Dependency Injection (DI) ช่วยลดภาระทางปัญญา (cognitive load) สำหรับนักพัฒนาที่ทำงานกับแอปพลิเคชันขนาดใหญ่ได้อย่างมาก และยังช่วยปรับปรุงการทำงานร่วมกันในทีม TypeScript กำหนดสัญญา (contracts) ที่ชัดเจนผ่านอินเทอร์เฟซและไทป์สำหรับการโต้ตอบระหว่างข้อมูลและเซอร์วิส สถาปัตยกรรมแบบโมดูลาร์ช่วยแบ่งแอปพลิเคชันออกเป็นหน่วยย่อยๆ ที่จัดการได้ง่ายและมีความสมบูรณ์ในตัวเอง Dependency Injection กำหนดวิธีการที่หน่วยเหล่านี้โต้ตอบกันและรับ dependencies ของตนอย่างชัดเจน แนวทางที่มีโครงสร้างนี้หมายความว่านักพัฒนาสามารถทำความเข้าใจโมดูลหรือเซอร์วิสที่เฉพาะเจาะจงได้โดยไม่จำเป็นต้องเข้าใจความซับซ้อนทั้งหมดของแอปพลิเคชันในคราวเดียว อินเทอร์เฟซที่ชัดเจนและ DI ทำให้ง่ายสำหรับนักพัฒนาหลายคนในการทำงานกับส่วนต่างๆ ของแอปพลิเคชันพร้อมกันโดยไม่เกิดปัญหากระทบกระทั่งกัน1.2. การตั้งค่าสภาพแวดล้อมการพัฒนาก่อนเริ่มต้นพัฒนาด้วย NestJS จำเป็นต้องตรวจสอบให้แน่ใจว่าได้ติดตั้ง Node.js (เวอร์ชัน >= 20 ตามเอกสาร แม้ว่า จะกล่าวถึง v18.2.0 ซึ่งก็ยังใช้งานได้กับ NestJS เวอร์ชันล่าสุดส่วนใหญ่) และตัวจัดการแพ็กเกจ NPM หรือ Yarn เรียบร้อยแล้วขั้นตอนถัดไปคือการติดตั้ง Nest CLI (Command Line Interface) แบบ global โดยใช้คำสั่ง:npm install -g @nestjs/cliCLI เป็นเครื่องมือสำคัญที่ช่วยในการสร้างโครงสร้างโปรเจกต์ (scaffolding) และการจัดการโปรเจกต์ NestJS นอกจากนี้ ยังมีทางเลือกในการใช้คำสั่ง npx @nestjs/cli@latest สำหรับการรันคำสั่ง CLI เพียงครั้งเดียวโดยไม่ต้องติดตั้งแบบ globalบทบาทของ Nest CLI ไม่ได้จำกัดอยู่แค่การสร้างโปรเจกต์ใหม่เท่านั้น แต่ยังรวมถึงการบังคับใช้โครงสร้างโปรเจกต์ที่เป็นมาตรฐานและส่งเสริมแนวทางปฏิบัติที่ดีที่สุดตั้งแต่เริ่มต้น ซึ่งมีค่าอย่างยิ่งสำหรับความสอดคล้อง โดยเฉพาะอย่างยิ่งในสภาพแวดล้อมการทำงานเป็นทีม หากไม่มี CLI นักพัฒนาอาจสร้างโครงสร้างโปรเจกต์ที่แตกต่างกันไป ทำให้เกิดความไม่สอดคล้องกัน CLI จะสร้างโมดูล คอนโทรลเลอร์ เซอร์วิส และไฟล์ทดสอบด้วยโครงสร้างที่กำหนดไว้ล่วงหน้า โครงสร้างที่สอดคล้องกันนี้ทำให้นักพัฒนาในทีมสามารถค้นหาและทำความเข้าใจส่วนต่างๆ ของโค้ดเบสได้ง่ายขึ้น ไม่ว่าใครจะเป็นผู้เขียนก็ตาม นอกจากนี้ยังช่วยลดความซับซ้อนในการนำรูปแบบทั่วไปมาใช้และลดโค้ดที่ต้องเขียนซ้ำๆ (boilerplate)1.3. การสร้างโปรเจกต์ NestJS ใหม่ และการทำความเข้าใจโครงสร้างเริ่มต้นการสร้างโปรเจกต์ NestJS ใหม่สามารถทำได้โดยใช้คำสั่ง nest new project-name ระหว่างกระบวนการนี้ CLI จะถามให้เลือกตัวจัดการแพ็กเกจระหว่าง NPM และ Yarnเมื่อสร้างโปรเจกต์เสร็จสิ้น จะได้โครงสร้างโปรเจกต์พื้นฐานดังนี้:
src/: โฟลเดอร์หลักที่เก็บซอร์สโค้ดของแอปพลิเคชัน
test/: โฟลเดอร์สำหรับเก็บไฟล์ทดสอบ (โดยเฉพาะ E2E tests)
node_modules/: โฟลเดอร์ที่เก็บ dependencies ของโปรเจกต์
package.json: ไฟล์ที่ระบุ dependencies และสคริปต์ต่างๆ ของโปรเจกต์
tsconfig.json: ไฟล์กำหนดค่าสำหรับ TypeScript compiler
.eslintrc.js: ไฟล์กำหนดค่าสำหรับ ESLint (linter)
ภายในโฟลเดอร์ src/ จะมีไฟล์หลักๆ ที่สำคัญดังนี้ 1:
main.ts: เป็นจุดเริ่มต้น (entry point) ของแอปพลิเคชัน ใช้ NestFactory ในการสร้าง instance ของแอปพลิเคชัน, โหลด AppModule (root module) และเริ่ม HTTP listener เพื่อรอรับ request 1
app.module.ts: เป็น root module ของแอปพลิเคชัน 1
app.controller.ts: เป็นคอนโทรลเลอร์พื้นฐานที่มี route เดียว 1
app.service.ts: เป็นเซอร์วิสพื้นฐานที่มี method เดียว 1
app.controller.spec.ts: เป็นไฟล์ unit test สำหรับคอนโทรลเลอร์
ในการรันแอปพลิเคชัน สามารถใช้คำสั่ง npm run start:dev ซึ่งโดยทั่วไปคำสั่งนี้จะเฝ้าดูการเปลี่ยนแปลงของไฟล์และทำการรีโหลดเซิร์ฟเวอร์โดยอัตโนมัติโครงสร้างโปรเจกต์เริ่มต้นนี้เป็นการนำเสนอแนวคิดหลักของโมดูล คอนโทรลเลอร์ และเซอร์วิสในทันที ซึ่งเป็นการชี้นำให้นักพัฒนามุ่งเน้นไปที่การแบ่งแยกหน้าที่ความรับผิดชอบ (separation of concerns) ตั้งแต่เริ่มต้น การมีอยู่ของไฟล์ app.module.ts, app.controller.ts, และ app.service.ts ไม่ใช่เรื่องบังเอิญ แต่เป็นการเสริมสร้างแนวคิดที่ว่าแอปพลิเคชันควรถูกแบ่งออกเป็นหน่วยตรรกะเหล่านี้ทั้งในเชิงโครงสร้างและสายตา สิ่งนี้ช่วยให้นักพัฒนา NestJS หน้าใหม่ซึมซับรูปแบบนี้ได้อย่างรวดเร็ว แทนที่จะต้องคิดค้นกลยุทธ์การจัดระเบียบด้วยตนเองตาราง: คำสั่ง Nest CLI ที่ใช้บ่อยNest CLI เป็นหัวใจสำคัญของผลิตภาพของนักพัฒนา ตารางอ้างอิงฉบับย่อนี้รวบรวมคำสั่งที่ใช้บ่อยที่สุดสำหรับการสร้างโครงสร้างและการรันแอปพลิเคชัน ซึ่งช่วยให้ผู้เข้าร่วมเวิร์คชอปคุ้นเคยกับ CLI ได้อย่างรวดเร็วและลดความจำเป็นในการค้นหาคำสั่งอยู่เสมอ ทั้งยังเป็นการตอกย้ำว่า CLI เป็นเครื่องมือที่มีประสิทธิภาพในการรักษาความสอดคล้องและเร่งความเร็วในการพัฒนาคำสั่งAliasคำอธิบายnest new <project-name>nสร้างโครงสร้างแอปพลิเคชันใหม่ในโหมดมาตรฐาน (S6)nest generate module <name>g moสร้างโมดูลใหม่ (S4, S6)nest generate controller <name>g coสร้างคอนโทรลเลอร์ใหม่ (S4, S6)nest generate service <name>g sสร้างเซอร์วิสใหม่ (S4, S6)nest generate resource <name>g resสร้างโมดูล, คอนโทรลเลอร์, เซอร์วิส, DTOs, และ entity (สร้างโครงสร้าง CRUD)npm run start:devรันแอปพลิเคชันในโหมด development พร้อม watch (S6)โมดูลที่ 2: แนวคิดหลักของ NestJS2.1. โมดูลสำหรับการจัดระเบียบแอปพลิเคชันโมดูลใน NestJS ซึ่งกำหนดโดยใช้ decorator @Module() ทำหน้าที่เป็นหน่วยโครงสร้างพื้นฐาน (building blocks) ที่ช่วยจัดระเบียบแอปพลิเคชันออกเป็นส่วนๆ ที่มีความสัมพันธ์กันตามฟังก์ชันการทำงาน โมดูลช่วยในการห่อหุ้ม (encapsulation) และจัดกลุ่มคอนโทรลเลอร์, เซอร์วิส, และ providers อื่นๆ ที่เกี่ยวข้องเข้าด้วยกันDecorator @Module() รับอ็อบเจกต์การกำหนดค่าที่มีคุณสมบัติหลักๆ ดังนี้:
imports: อาร์เรย์ของโมดูลอื่นๆ ที่โมดูลปัจจุบันต้องการใช้งาน providers ที่ถูก export ออกมา
controllers: อาร์เรย์ของคอนโทรลเลอร์ที่จะถูกสร้าง instance ภายในโมดูลนี้
providers: อาร์เรย์ของ providers (เช่น เซอร์วิส) ที่จะถูกสร้าง instance โดย Nest injector และสามารถแชร์กันภายในโมดูลนี้ได้
exports: อาร์เรย์ย่อยของ providers ที่จะถูกทำให้พร้อมใช้งานสำหรับโมดูลอื่นๆ ที่ import โมดูลปัจจุบัน
AppModule ถือเป็น root module ของแอปพลิเคชัน และเป็นจุดเริ่มต้นในการประกอบสร้างส่วนต่างๆ ของแอปพลิเคชันโมดูลของ NestJS ไม่ได้มีไว้เพื่อการจัดระเบียบโค้ดเท่านั้น แต่ยังเป็นกุญแจสำคัญในการจัดการขอบเขตของ Dependency Injection (DI scope) และเปิดใช้งานการพัฒนาตามคุณลักษณะ (feature-based development) โดยทั่วไปแล้ว Providers (เช่น เซอร์วิส) จะมีขอบเขตอยู่ภายในโมดูลของตนเอง เว้นแต่จะถูก export และ import ไปยังที่อื่นอย่างชัดเจน สิ่งนี้ช่วยให้ทีมหรือนักพัฒนาที่แตกต่างกันสามารถทำงานกับโมดูลคุณลักษณะที่แยกจากกันได้ในระดับหนึ่งของการแยกส่วน (isolation) การกำหนด imports และ exports ที่ชัดเจนจะกำหนด Public API ของโมดูล ซึ่งส่งเสริมการเชื่อมโยงแบบหลวม (loose coupling) ระหว่างส่วนต่างๆ ของแอปพลิเคชันระบบโมดูลาร์เมื่อรวมกับ TypeScript จะช่วยให้การปรับโครงสร้าง (refactoring) และการบำรุงรักษาในแอปพลิเคชันขนาดใหญ่ง่ายขึ้น หากคุณลักษณะใดจำเป็นต้องเปลี่ยนแปลงหรือลบออก ผลกระทบมักจะจำกัดอยู่ภายในโมดูลนั้นๆ และ TypeScript จะช่วยระบุ dependencies ที่เสียหายข้ามขอบเขตโมดูลในระหว่างการคอมไพล์ ขอบเขตโมดูลที่กำหนดไว้อย่างดีจะจำกัด "รัศมีการระเบิด" (blast radius) ของการเปลี่ยนแปลง หากเซอร์วิสภายใน ModuleA ถูกปรับโครงสร้าง เฉพาะโมดูลที่ import ModuleA อย่างชัดเจนและใช้เซอร์วิสนั้นเท่านั้นที่อาจได้รับผลกระทบ การตรวจสอบประเภทแบบสแตติกของ TypeScript จะแจ้งข้อผิดพลาดทันทีหากลายเซ็นเมธอดหรือประเภทที่ export ออกไปมีการเปลี่ยนแปลง ซึ่งช่วยป้องกันปัญหาที่ไม่คาดคิดในขณะรันไทม์2.2. คอนโทรลเลอร์สำหรับการจัดการคำขอที่เข้ามาคอนโทรลเลอร์ ซึ่งกำหนดโดยใช้ decorator @Controller() มีหน้าที่รับผิดชอบในการจัดการคำขอ HTTP ที่เข้ามาและส่งคืนการตอบสนองกลับไปยัง client NestJS มี decorators สำหรับการจัดการ route ต่างๆ เช่น:
@Get(): สำหรับ HTTP GET request
@Post(): สำหรับ HTTP POST request
@Put(): สำหรับ HTTP PUT request
@Delete(): สำหรับ HTTP DELETE request
@Param(): สำหรับการดึงข้อมูล route parameters (เช่น /todos/:id)
@Body(): สำหรับการดึงข้อมูล request body
@Query(): สำหรับการดึงข้อมูล query parameters
คอนโทรลเลอร์มักจะมอบหมายตรรกะทางธุรกิจ (business logic) ให้กับเซอร์วิส โดยทำหน้าที่เป็น "ผู้ประสานงาน" (orchestrator) ที่รับคำขอ เรียกใช้ตรรกะทางธุรกิจ และจัดรูปแบบการตอบสนองคอนโทรลเลอร์ของ NestJS ผ่านการใช้ decorators เป็นวิธีการประกาศ (declarative) ในการกำหนด API endpoints ซึ่งช่วยปรับปรุงความสามารถในการอ่านโค้ดและลดโค้ด boilerplate ได้อย่างมากเมื่อเทียบกับการกำหนด route แบบดั้งเดิมใน Express.js ใน Express การกำหนด routes มักจะเป็นแบบคำสั่ง (imperative) (เช่น app.get('/path', handler)) ในขณะที่ decorators ของ NestJS (เช่น @Get(), @Post()) จะเชื่อมโยงเมธอดของคลาสกับ HTTP method และ path อย่างชัดเจน การวางตำแหน่งคำจำกัดความของ route และตรรกะของ handler ไว้ด้วยกันภายในคลาสคอนโทรลเลอร์ทำให้เข้าใจโครงสร้างของ API ได้ง่ายขึ้น2.3. เซอร์วิสและ Providers สำหรับตรรกะทางธุรกิจเซอร์วิส ซึ่งกำหนดโดยใช้ decorator @Injectable() เป็น providers ประเภทหนึ่งที่รับผิดชอบในการห่อหุ้มตรรกะทางธุรกิจ การเข้าถึงข้อมูล และข้อกังวลอื่นๆ เซอร์วิสสามารถถูก inject เข้าไปในคอนโทรลเลอร์หรือเซอร์วิสอื่นๆ ได้ Providers เป็นแนวคิดพื้นฐานในระบบ DI ของ NestJS และเซอร์วิสเป็นประเภทของ provider ที่พบบ่อยที่สุดDecorator @Injectable() มีความสำคัญอย่างยิ่งต่อระบบ DI ของ NestJS มันส่งสัญญาณว่าคลาสสามารถถูกจัดการโดย Nest IoC container ทำให้สามารถถูก inject เป็น dependency ในที่อื่นได้ นี่คือรากฐานของการเชื่อมโยงแบบหลวม (loose coupling) หากไม่มี @Injectable() NestJS จะไม่ทราบว่าคลาสมีจุดประสงค์เพื่อเป็น provider IoC container ต้องการข้อมูลเมตานี้เพื่อจัดการวงจรชีวิตและการ inject ของเซอร์วิส สิ่งนี้ทำให้เซอร์วิสสามารถสับเปลี่ยนหรือจำลอง (mock) ได้ง่ายสำหรับการทดสอบ ซึ่งเป็นประโยชน์หลักของ DI2.4. การทำความเข้าใจ Dependency Injection (DI) อย่างลึกซึ้งDependency Injection (DI) เป็นรูปแบบการออกแบบ (design pattern) ที่ dependencies ของคลาสจะถูกจัดหาให้จากภายนอก แทนที่คลาสจะสร้าง dependencies เหล่านั้นขึ้นมาเอง ใน NestJS, DI มักจะถูกนำมาใช้ผ่าน constructor injectionNest IoC (Inversion of Control) container มีบทบาทสำคัญในการจัดการและ inject dependencies ประโยชน์ของ DI ได้แก่ การเชื่อมโยงแบบหลวม (loose coupling), ความสามารถในการทดสอบที่ดีขึ้น, การจัดระเบียบโค้ดที่ดีขึ้น และการบำรุงรักษาที่ง่ายขึ้นDependency Injection ไม่ได้เป็นเพียงคุณสมบัติหนึ่งของ NestJS แต่เป็น รากฐานสำคัญ ของสถาปัตยกรรม การทำความเข้าใจ DI เป็นพื้นฐานสำคัญในการใช้ประโยชน์จาก NestJS อย่างมีประสิทธิภาพเพื่อสร้างแอปพลิเคชันที่ซับซ้อน ทดสอบได้ และบำรุงรักษาได้ง่าย DI ช่วยให้เกิดการแบ่งแยกหน้าที่ความรับผิดชอบโดยอนุญาตให้คลาสรับ dependencies จากแหล่งภายนอก (IoC container) ทำให้คลาสเป็นอิสระจากวิธีการสร้างหรือกำหนดค่า dependencies ของตน ความเป็นอิสระนี้มีความสำคัญอย่างยิ่งสำหรับการทดสอบหน่วย (unit testing) เนื่องจาก dependencies สามารถถูกแทนที่ด้วย mocks หรือ stubs ได้อย่างง่ายดาย นอกจากนี้ยังส่งเสริมการนำโค้ดกลับมาใช้ใหม่ (reusability) เนื่องจากเซอร์วิสสามารถถูก inject ได้ทุกที่ที่ต้องการโดยไม่มีการเชื่อมโยงที่แน่นหนาIoC container ใน NestJS โดยการจัดการวงจรชีวิตของอ็อบเจกต์และ dependencies ช่วยลดความซับซ้อนของกราฟแอปพลิเคชันที่ซับซ้อน นักพัฒนาสามารถมุ่งเน้นไปที่การกำหนดความสัมพันธ์ระหว่างคอมโพเนนต์ต่างๆ และเฟรมเวิร์กจะจัดการ "การเดินสาย" (wiring) ซึ่งช่วยลดโค้ด boilerplate และข้อผิดพลาดที่อาจเกิดขึ้นจากการจัดการ dependency ด้วยตนเอง ในแอปพลิเคชันขนาดใหญ่ การติดตามว่าอ็อบเจกต์ถูกสร้างและส่งต่อกันอย่างไรอาจซับซ้อนมาก IoC container จะรวมศูนย์การจัดการนี้ นักพัฒนาประกาศ dependencies (เช่น ใน constructors) และ NestJS จะแก้ไข dependencies เหล่านั้นตาม providers ของโมดูล การสรุปนี้ทำให้ระบบโดยรวมเข้าใจง่ายขึ้นและมีโอกาสเกิดข้อผิดพลาดน้อยลง เช่น circular dependencies หรือการสร้าง instance ที่ไม่ถูกต้องส่วนที่ 2: การสร้างแกนหลักของแอปพลิเคชัน Todoโมดูลที่ 3: การออกแบบและตรวจสอบความถูกต้องของ Todo API3.1. การกำหนดคุณสมบัติของ Todo และ API Endpoints (CRUD)ในการเริ่มต้นสร้างแอปพลิเคชัน Todo ผู้เข้าร่วมเวิร์คชอปจะร่วมกันกำหนดคุณสมบัติที่จำเป็นสำหรับรายการ Todo หนึ่งรายการ เช่น id (ตัวระบุ), title (ชื่อเรื่อง), description (คำอธิบาย), isCompleted (สถานะว่าเสร็จสิ้นแล้วหรือไม่), createdAt (เวลาที่สร้าง), และ updatedAt (เวลาที่อัปเดตล่าสุด)จากนั้น คุณสมบัติเหล่านี้จะถูกแมปเข้ากับ API endpoints แบบ RESTful สำหรับการดำเนินการ CRUD (Create, Read, Update, Delete) พื้นฐาน:
POST /todos - สร้างรายการ Todo ใหม่
GET /todos - ดึงข้อมูลรายการ Todo ทั้งหมด
GET /todos/:id - ดึงข้อมูลรายการ Todo เดียวตาม ID
PUT /todos/:id (หรือ PATCH) - อัปเดตรายการ Todo ที่มีอยู่
DELETE /todos/:id - ลบรายการ Todo
หลังจากกำหนด endpoints แล้ว จะใช้ Nest CLI ในการสร้างโครงสร้างพื้นฐานสำหรับ TodoModule, TodoController, และ TodoService เพื่อเป็นฐานในการพัฒนาต่อไปการกำหนดสัญญา API ที่ชัดเจน ก่อน การลงมือเขียนโค้ด (แม้แต่สำหรับแอปพลิเคชันง่ายๆ) เป็นแนวทางปฏิบัติที่ดีที่สุดที่สำคัญ สิ่งนี้ช่วยในการปรับแนวทางการพัฒนาระหว่าง frontend และ backend และอำนวยความสะดวกในการทดสอบที่ดีขึ้น สัญญาที่กำหนดไว้ (endpoints, รูปแบบ request/response) ช่วยให้สามารถพัฒนาแบบขนานได้ ทำหน้าที่เป็นเอกสารสำหรับผู้บริโภค API และทำให้การเขียนการทดสอบระดับ API (E2E tests) ง่ายขึ้นเนื่องจากพฤติกรรมที่คาดหวังมีความชัดเจน3.2. การนำ Data Transfer Objects (DTOs) มาใช้งานData Transfer Objects (DTOs) เป็นอ็อบเจกต์ที่กำหนดวิธีการส่งข้อมูลผ่านเครือข่าย ทำหน้าที่เป็นเหมือนสัญญา (contract) ระหว่าง client และ server 2 การใช้ DTOs มีประโยชน์หลายประการ:
การตรวจสอบความถูกต้องของข้อมูล (Data Validation): ทำให้มั่นใจได้ว่าข้อมูลที่เข้ามาตรงตามรูปแบบที่คาดไว้
ความปลอดภัยของประเภทข้อมูล (Type Safety): ใช้ประโยชน์จาก TypeScript เพื่อบังคับใช้ประเภทข้อมูล
การลดการพึ่งพิงกัน (Decoupling): แยกโครงสร้างข้อมูลออกจากตรรกะทางธุรกิจ
เอกสารประกอบ (API Documentation): กำหนดรูปร่างของข้อมูลสำหรับ APIs อย่างชัดเจน 2
ในเวิร์คชอปนี้ จะมีการสร้าง CreateTodoDto สำหรับการสร้าง Todo ใหม่ และ UpdateTodoDto สำหรับการอัปเดต Todo ที่มีอยู่ DTOs เหล่านี้จะถูกใช้ในเมธอดของคอนโทรลเลอร์ร่วมกับ decorator @Body() เพื่อดึงข้อมูลจาก request bodyDTOs ทำหน้าที่เป็นชั้นขอบเขต (boundary layer) ที่สำคัญระหว่างคำขอจากเครือข่ายและชั้นเซอร์วิสของแอปพลิเคชัน ทำให้มั่นใจได้ว่าชั้นเซอร์วิสได้รับข้อมูลในรูปแบบที่คาดการณ์ได้และผ่านการตรวจสอบความถูกต้องแล้ว โดยไม่ขึ้นอยู่กับโครงสร้างของคำขอดิบ คำขอดิบอาจมีรูปแบบที่ไม่ถูกต้องหรือมีข้อมูลที่ไม่คาดคิด DTOs โดยเฉพาะเมื่อใช้ร่วมกับการตรวจสอบความถูกต้อง จะทำหน้าที่เป็นผู้เฝ้าประตู สิ่งนี้ช่วยปกป้องชั้นเซอร์วิสจากการจัดการกับข้อมูลที่ไม่ถูกต้องและลดความซับซ้อนของตรรกะ นอกจากนี้ยังช่วยลดการพึ่งพิงของชั้นเซอร์วิสกับกลไกการขนส่งข้อมูลที่เฉพาะเจาะจง (เช่น HTTP)3.3. การตรวจสอบความถูกต้องของข้อมูลนำเข้าที่แข็งแกร่งด้วย class-validator และ ValidationPipeเพื่อให้มั่นใจว่าข้อมูลที่ส่งเข้ามายัง API มีความถูกต้อง จะมีการนำไลบรารี class-validator และ class-transformer มาใช้งาน 2 โดยมีขั้นตอนดังนี้:
ติดตั้ง dependencies: npm install class-validator class-transformer
เพิ่ม validation decorators ให้กับ DTOs: ใช้ decorators เช่น @IsString(), @IsNotEmpty(), @IsBoolean(), @IsOptional() กับคุณสมบัติต่างๆ ใน CreateTodoDto และ UpdateTodoDto 2
ใช้งาน ValidationPipe แบบ global: กำหนดค่า ValidationPipe ในไฟล์ main.ts เพื่อให้มีการตรวจสอบ DTOs ที่เข้ามาโดยอัตโนมัติทั่วทั้งแอปพลิเคชัน 2 ValidationPipe ไม่เพียงแต่ตรวจสอบความถูกต้อง แต่ยังสามารถแปลง payload ที่เข้ามาให้เป็น instance ของ DTO class ได้ด้วย
การจัดการข้อผิดพลาด: เมื่อการตรวจสอบความถูกต้องล้มเหลว NestJS จะส่งคืนการตอบสนอง HTTP ที่มีโครงสร้างข้อผิดพลาดที่ชัดเจนโดยอัตโนมัติ
ValidationPipe แบบ global ช่วยลดโค้ด boilerplate ในคอนโทรลเลอร์ได้อย่างมาก หากไม่มีมัน นักพัฒนาจะต้องเรียกใช้การตรวจสอบความถูกต้องสำหรับ DTO ทุกตัวในทุก handler ด้วยตนเอง การเรียกใช้เซอร์วิสหรือฟังก์ชันการตรวจสอบความถูกต้องด้วยตนเองในแต่ละเมธอดของคอนโทรลเลอร์นั้นซ้ำซากและมีโอกาสเกิดข้อผิดพลาดได้ง่าย ValidationPipe เมื่อลงทะเบียนแบบ global จะดักจับคำขอที่มี DTOs และใช้กฎการตรวจสอบความถูกต้องโดยอัตโนมัติ ทำให้ตรรกะของคอนโทรลเลอร์สะอาดขึ้นและมุ่งเน้นไปที่การประสานงานมากกว่ากลไกการตรวจสอบความถูกต้องการใช้ decorators ของ class-validator โดยตรงบน DTOs ทำให้กฎการตรวจสอบความถูกต้องเป็นแบบประกาศ (declarative) และอยู่ร่วมกับคำจำกัดความของโครงสร้างข้อมูล สิ่งนี้ช่วยปรับปรุงความสามารถในการบำรุงรักษา เนื่องจากนักพัฒนาสามารถเห็นกฎที่ใช้กับแต่ละฟิลด์ได้อย่างง่ายดาย หากตรรกะการตรวจสอบความถูกต้องแยกจากกัน (เช่น ในเมธอดของเซอร์วิส) จะติดตามได้ยากว่ากฎใดใช้กับฟิลด์ DTO ใด Decorators เป็นวิธีการที่กระชับและอ่านง่ายในการกำหนดกฎเหล่านี้โดยตรงบนคุณสมบัติของ DTO ลักษณะที่เป็นเอกสารในตัวเองของ DTOs นี้ช่วยเพิ่มความชัดเจนของโค้ดและลดโอกาสที่กฎการตรวจสอบความถูกต้องจะล้าสมัยหรือถูกมองข้ามระหว่างการปรับโครงสร้างโมดูลที่ 4: การผสานรวมฐานข้อมูลด้วย TypeORM และ SQLite4.1. ความรู้เบื้องต้นเกี่ยวกับ TypeORM ในบริบทของ NestJSTypeORM เป็น ORM (Object-Relational Mapper) สำหรับ TypeScript และ JavaScript ที่รองรับฐานข้อมูลหลากหลายประเภท เหตุผลที่ควรใช้ TypeORM กับ NestJS คือการสนับสนุน TypeScript, รูปแบบ Active Record และ Data Mapper, และการผสานรวมที่ง่ายดายในการเริ่มต้น จะต้องติดตั้ง TypeORM และไดรเวอร์สำหรับ SQLite:npm install --save @nestjs/typeorm typeorm sqlite3(เอกสาร ยังกล่าวถึง reflect-metadata ซึ่งมักจะเป็น peer dependency หรือถูกจัดการโดยแกนหลักของ NestJS)แพ็กเกจ @nestjs/typeorm มีความสำคัญอย่างยิ่ง เนื่องจากมี wrappers และ utilities ที่จำเป็น (เช่น TypeOrmModule, InjectRepository) เพื่อผสานรวม TypeORM เข้ากับระบบ DI และโครงสร้างโมดูลของ NestJS ได้อย่างราบรื่น TypeORM เองเป็น ORM แบบสแตนด์อโลน @nestjs/typeorm ทำหน้าที่เชื่อมต่อ TypeORM กับสถาปัตยกรรมของ NestJS TypeOrmModule.forRoot() และ TypeOrmModule.forFeature() ใช้สำหรับกำหนดค่า TypeORM ในระดับโมดูล @InjectRepository() ช่วยให้สามารถ inject TypeORM repositories เข้าไปในเซอร์วิสโดยใช้ DI ของ NestJS หากไม่มีแพ็กเกจนี้ การผสานรวมจะต้องทำด้วยตนเองและซับซ้อนกว่ามาก4.2. การกำหนดค่า TypeORM สำหรับ SQLiteการกำหนดค่า TypeORM สำหรับ SQLite จะทำผ่าน TypeOrmModule.forRoot() ใน AppModule (หรือโมดูลฐานข้อมูลที่แยกต่างหาก) ตัวอย่างการกำหนดค่า:TypeScript// ใน app.module.ts หรือโมดูลฐานข้อมูลที่แยกต่างหาก
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Todo } from './todo/todo.entity'; // สมมติว่า entity อยู่ที่นี่

@Module({
  imports:, // หรือ [__dirname + '/../**/*.entity{.ts,.js}']
      synchronize: true, // อธิบายว่าใช้สำหรับการพัฒนาเท่านั้น
    }),
    //... other modules
  ],
})
export class AppModule {}
อธิบายตัวเลือกต่างๆ:
type: 'sqlite' ระบุประเภทฐานข้อมูล
database: ชื่อไฟล์ฐานข้อมูล SQLite
entities: อาร์เรย์ของ entity classes หรือ path glob ที่ชี้ไปยังไฟล์ entity
synchronize: true: ตัวเลือกนี้มีประโยชน์มากในระหว่างการพัฒนา เนื่องจาก TypeORM จะสร้างสกีมาฐานข้อมูลโดยอัตโนมัติตามคำจำกัดความของ entity อย่างไรก็ตาม ตัวเลือกนี้อันตรายสำหรับสภาพแวดล้อม production เนื่องจากอาจทำให้ข้อมูลสูญหายได้ 3 จะมีการกล่าวถึง migrations ซึ่งเป็นทางเลือกสำหรับ production ในภายหลัง
อาร์เรย์ entities ในการกำหนดค่า TypeORM ที่ใช้รูปแบบ glob (เช่น [__dirname + '/../**/*.entity{.ts,.js}']) เป็นแนวทางปฏิบัติทั่วไปที่ช่วยให้ TypeORM ค้นพบไฟล์ entity ทั้งหมดโดยอัตโนมัติโดยไม่จำเป็นต้องระบุรายการด้วยตนเอง ซึ่งช่วยปรับปรุงความสามารถในการบำรุงรักษาเนื่องจาก entity ใหม่จะถูกตรวจจับโดยอัตโนมัติ การระบุรายการไฟล์ entity ทุกไฟล์ด้วยตนเองในการกำหนดค่านั้นมีโอกาสเกิดข้อผิดพลาดและน่าเบื่อ รูปแบบ glob จะค้นหาไฟล์ทั้งหมดที่ตรงกับรูปแบบ .entity.ts (หรือ .js) แบบไดนามิก ซึ่งช่วยลดภาระงานในการกำหนดค่าเมื่อเพิ่มหรือลบ entitiesความสะดวกของ synchronize: true ในระหว่างการพัฒนาอาจนำไปสู่นิสัยที่ไม่ดีหากไม่ได้รับการอธิบายอย่างถูกต้อง ผู้เข้าร่วมเวิร์คชอป ต้อง เข้าใจว่าการตั้งค่านี้ ไม่ควรใช้ ใน production เนื่องจากมีความเสี่ยงต่อการสูญเสียข้อมูล สิ่งนี้เป็นการปูทางไปสู่การทำความเข้าใจความจำเป็นของ database migrations synchronize: true ทำงานโดยการ drop และสร้างตารางใหม่ หรือแก้ไขตารางให้ตรงกับคำจำกัดความของ entity หากคุณสมบัติของ entity ถูกลบหรือเปลี่ยนชื่อ คอลัมน์ที่เกี่ยวข้องและข้อมูลในนั้นอาจถูก drop ในสภาพแวดล้อมการพัฒนาที่มีข้อมูลทดสอบ สิ่งนี้มักจะยอมรับได้ แต่ใน production สิ่งนี้จะนำไปสู่การสูญเสียข้อมูลที่ไม่สามารถย้อนกลับได้ Migrations จะให้การเปลี่ยนแปลงสกีมาที่มีการควบคุมและมีเวอร์ชัน4.3. การกำหนด Todo Entityสร้างไฟล์ todo.entity.ts และกำหนดคลาส Todo ด้วย TypeORM decorators: @Entity(), @PrimaryGeneratedColumn(), @Column(), @CreateDateColumn(), @UpdateDateColumn() คุณสมบัติของ Todo (id, title, description, isCompleted, createdAt, updatedAt) จะถูกแมปเข้ากับคอลัมน์ฐานข้อมูลด้วยประเภทข้อมูลที่เหมาะสมตัวอย่าง Todo Entity:TypeScriptimport { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn } from 'typeorm';

@Entity()
export class Todo {
  @PrimaryGeneratedColumn('uuid') // หรือ 'increment' สำหรับตัวเลข
  id: string; // หรือ number

  @Column()
  title: string;

  @Column({ type: 'text', nullable: true })
  description?: string;

  @Column({ default: false })
  isCompleted: boolean;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}
TypeORM entities ทำหน้าที่เป็นสะพานเชื่อมระหว่างโลกเชิงวัตถุของ TypeScript/NestJS และโลกเชิงสัมพันธ์ของฐานข้อมูล SQL Decorators เป็นวิธีการประกาศ (declarative) ในการกำหนดการแมปนี้ นักพัฒนาทำงานกับคลาสและอ็อบเจกต์ TypeScript ฐานข้อมูลจัดเก็บข้อมูลในตารางและแถว ORM entities โดยใช้ decorators กำหนดว่าคุณสมบัติของคลาสแมปกับคอลัมน์ตาราง ประเภทข้อมูล ความสัมพันธ์ ฯลฯ อย่างไร การสรุปนี้ช่วยให้นักพัฒนาคิดในแง่ของอ็อบเจกต์ในขณะที่ TypeORM จัดการการแปล SQL4.4. การนำ Repository Pattern มาใช้สำหรับการเข้าถึงข้อมูลRepository Pattern เป็นรูปแบบการออกแบบที่ช่วยสรุปตรรกะการเข้าถึงข้อมูล ทำให้เซอร์วิสเป็นอิสระจากการ υλοποίηση ของแหล่งข้อมูลที่เฉพาะเจาะจง 4 ใน TodoService จะใช้ @InjectRepository(Todo) เพื่อ inject TypeORM repository สำหรับ Todo entityจากนั้นจะสามารถใช้เมธอดพื้นฐานของ repository เช่น find(), findOne(), save(), remove(), update() ในการโต้ตอบกับฐานข้อมูล 4Repository Pattern ซึ่งอำนวยความสะดวกโดย @InjectRepository() เป็นกุญแจสำคัญสำหรับเซอร์วิสที่ทดสอบได้ง่าย ช่วยให้สามารถจำลอง (mock) repository ใน unit tests แยกตรรกะของเซอร์วิสออกจากการโต้ตอบกับฐานข้อมูลจริง เซอร์วิสควรมีตรรกะทางธุรกิจ ไม่ใช่โค้ดการเข้าถึงฐานข้อมูลโดยตรง (เช่น การเขียนคำสั่ง SQL) repository (จัดหาโดย TypeORM ผ่าน @InjectRepository()) จัดการการโต้ตอบกับฐานข้อมูล ใน unit tests สำหรับเซอร์วิส repository ที่ถูก inject นี้สามารถจำลองได้อย่างง่ายดาย ซึ่งหมายความว่าตรรกะของเซอร์วิสสามารถทดสอบได้โดยไม่จำเป็นต้องเชื่อมต่อฐานข้อมูลจริง ทำให้การทดสอบเร็วขึ้นและเชื่อถือได้มากขึ้นแม้ว่า Repository ของ TypeORM จะให้ระดับการสรุปที่ดีอยู่แล้ว สำหรับแอปพลิเคชันที่ซับซ้อนมากหรือเมื่อต้องการสับเปลี่ยน ORM ทั้งหมด นักพัฒนาอาจสร้างอินเทอร์เฟซ repository ของตนเองทับบน TypeORM อีกชั้นหนึ่ง เวิร์คชอปสามารถกล่าวถึงสิ่งนี้สั้นๆ ว่าเป็นขั้นตอนขั้นสูงนอกเหนือจากการ inject Repository<Entity> โดยตรง การขึ้นอยู่กับ Repository<Entity> จาก typeorm โดยตรงยังคงผูกเซอร์วิสเข้ากับ TypeORM ชั้นการสรุปเพิ่มเติม (เช่น interface ITodoRepository) จะทำให้เซอร์วิสขึ้นอยู่กับอินเทอร์เฟซนี้ และ TypeORMTodoRepository จะ υλοποίηση อินเทอร์เฟซนั้น สิ่งนี้จะช่วยลดการพึ่งพิงของเซอร์วิสมากยิ่งขึ้น ทำให้ทดสอบได้ง่ายขึ้นและปรับให้เข้ากับกลไกการจัดเก็บข้อมูลที่แตกต่างกันหรือแม้แต่ ORM ที่แตกต่างกันได้ แม้ว่าจะเพิ่มโค้ด boilerplate มากขึ้นก็ตาม4.5. การพัฒนาตรรกะ CRUD ของเซอร์วิสสำหรับ Todosใน TodoService จะมีการ υλοποίηση เมธอดต่างๆ เช่น create(), findAll(), findOne(), update(), และ remove() โดยใช้ TodoRepository ที่ถูก inject เข้ามา เมธอดเหล่านี้จะถูกเชื่อมต่อกับ handlers ใน TodoControllerหลังจาก υλοποίηση แล้ว จะทำการทดสอบการดำเนินการ CRUD ทั้งหมดโดยใช้เครื่องมือเช่น Postman หรือ Insomnia เพื่อยืนยันการทำงานที่ถูกต้องชั้นเซอร์วิสควรจัดการตรรกะทางธุรกิจหรือการแปลงข้อมูลใดๆ ระหว่างคอนโทรลเลอร์/DTOs และ repository สำหรับแอป Todo ง่ายๆ สิ่งนี้อาจมีน้อยมาก แต่ในแอปจริง เซอร์วิสจะประสานงานการเรียกไปยัง repositories หลายตัว ตรวจสอบกฎทางธุรกิจ ฯลฯ คอนโทรลเลอร์ควรบาง โดยส่วนใหญ่จัดการ request/response และการตรวจสอบ DTO repositories ควรจัดการเฉพาะการคงอยู่ของข้อมูล เซอร์วิสเชื่อมช่องว่างนี้ โดยมีตรรกะหลักของแอปพลิเคชัน การแบ่งแยกหน้าที่ความรับผิดชอบนี้ทำให้แต่ละชั้นมุ่งเน้นมากขึ้นและทดสอบได้ง่ายขึ้นส่วนที่ 3: การรับประกันคุณภาพโค้ดและแนวทางปฏิบัติที่ดีที่สุดโมดูลที่ 5: การเขียนโค้ดที่ทดสอบได้ - Unit Testing5.1. พื้นฐานของการทดสอบใน NestJSการทดสอบอัตโนมัติมีความสำคัญอย่างยิ่งในการพัฒนาซอฟต์แวร์ ปรัชญาการทดสอบของ NestJS คือการสนับสนุนในตัว การผสานรวมกับ Jest และ Supertest และการใช้ระบบ DI สำหรับการจำลอง (mocking) dependenciesเครื่องมือหลักที่ใช้คือ Test.createTestingModule() ซึ่งคล้ายกับการกำหนด @Module() แต่สำหรับสภาพแวดล้อมการทดสอบ และ TestingModule ที่เป็นผลลัพธ์ ไฟล์ทดสอบมักจะมีนามสกุล .spec.ts หรือ .test.ts และควรวางไว้ใกล้กับคลาสที่ทดสอบเครื่องมือช่วยทดสอบของ NestJS ใช้ประโยชน์จากระบบ DI ของมัน ทำให้สามารถใช้กลไกการแก้ไข dependency และการ inject แบบเดียวกับที่ใช้ในแอปพลิเคชันจริงในการทดสอบได้ สิ่งนี้ทำให้การตั้งค่าสภาพแวดล้อมการทดสอบด้วย mocks เป็นไปอย่างง่ายดาย Test.createTestingModule({...}) สะท้อน decorator @Module({...}) สามารถจัดหา mocks สำหรับเซอร์วิสหรือ repositories ในอาร์เรย์ providers ของ testing module ได้เช่นเดียวกับการจัดหา υλοποίηση จริงใน application module เมธอด get() บน TestingModule ที่คอมไพล์แล้วสามารถดึง instances ของเซอร์วิสหรือคอนโทรลเลอร์พร้อมกับ dependencies ที่ถูก mock ได้ แนวทางที่สอดคล้องกันนี้ช่วยลดความซับซ้อนในการตั้งค่าการทดสอบ5.2. Unit Testing Services: การจำลอง Dependencies อย่างมีประสิทธิภาพ (เช่น TypeORM Repositories)การทดสอบ unit test สำหรับเซอร์วิสจะมุ่งเน้นไปที่การทดสอบตรรกะทางธุรกิจภายในเซอร์วิสแบบแยกส่วน (isolation) สิ่งสำคัญคือการจำลอง TypeORM repositories โดยใช้ getRepositoryToken() ร่วมกับ mock objects หรือ functions ที่สร้างจาก jest.fn() 6ตัวอย่างเช่น ในการทดสอบ TodoService จะมีการจำลองการเรียกใช้เมธอดต่างๆ ของ TodoRepository และตรวจสอบการโต้ตอบ การจัดหา mock repository จะทำผ่าน provide: getRepositoryToken(TodoEntity), useValue: mockRepositoryObjectการจำลอง repository dependencies มีความสำคัญอย่างยิ่งสำหรับการทดสอบ unit test ของเซอร์วิสอย่างแท้จริง ทำให้มั่นใจได้ว่าการทดสอบรวดเร็ว เชื่อถือได้ และไม่ขึ้นอยู่กับฐานข้อมูลจริง โดยมุ่งเน้นไปที่ตรรกะของเซอร์วิสเท่านั้น Unit tests ควรทดสอบหน่วยเดียว (เช่น เมธอดของเซอร์วิส) แบบแยกส่วน หากการทดสอบเซอร์วิสโต้ตอบกับฐานข้อมูลจริง มันจะไม่ใช่ unit test บริสุทธิ์อีกต่อไป แต่จะกลายเป็นการทดสอบ integration การโต้ตอบกับฐานข้อมูลช้าและอาจไม่น่าเชื่อถือ (ปัญหาเครือข่าย สถานะข้อมูล) การจำลองช่วยให้สามารถควบคุมสิ่งที่ repository methods ส่งคืนได้อย่างแม่นยำ ทำให้สามารถทดสอบสถานการณ์ต่างๆ และกรณีขอบ (edge cases) ในตรรกะของเซอร์วิสได้ฟังก์ชัน getRepositoryToken() เป็น utility ที่จัดหาโดย @nestjs/typeorm ซึ่งสร้าง token ที่ไม่ซ้ำกันสำหรับ repository ของ entity ที่กำหนด token นี้ใช้ในระบบ DI เพื่อลงทะเบียนและ inject repositories การทำความเข้าใจ token นี้เป็นกุญแจสำคัญในการจัดหา mocks สำหรับ repositories ที่เฉพาะเจาะจงใน testing module อย่างถูกต้อง ระบบ DI ของ NestJS ทำงานกับ tokens สำหรับ custom providers สามารถใช้ string tokens หรือชื่อคลาสได้ สำหรับ TypeORM repositories ซึ่งสร้างขึ้นแบบไดนามิก จำเป็นต้องมีวิธีมาตรฐานในการรับ token ของตน getRepositoryToken(Entity) จัดหา token มาตรฐานนี้ การใช้ token นี้ใน Test.createTestingModule({ providers: }) ทำให้มั่นใจได้ว่า mock mockTodoRepo จะถูก inject เมื่อใดก็ตามที่มีการร้องขอ Repository<Todo>5.3. Unit Testing Controllersการทดสอบ unit test สำหรับคอนโทรลเลอร์จะมุ่งเน้นไปที่ตรรกะของคอนโทรลเลอร์เอง เช่น การจัดการคำขอ การโต้ตอบกับเซอร์วิส และการสร้างการตอบสนอง จะมีการจำลอง service dependencies ที่ถูก inject เข้ามาในคอนโทรลเลอร์วัตถุประสงค์หลักคือเพื่อตรวจสอบว่าเมธอดของคอนโทรลเลอร์เรียกใช้เมธอดของเซอร์วิสที่ถูกต้องด้วยอาร์กิวเมนต์ที่คาดหวัง และคอนโทรลเลอร์ส่งคืนการตอบสนองที่คาดหวังตามผลลัพธ์จากเซอร์วิสUnit tests ของคอนโทรลเลอร์ควรตรวจสอบ "การเดินสาย" (wiring) เป็นหลัก กล่าวคือ คอนโทรลเลอร์รับคำขออย่างถูกต้อง เรียกใช้เมธอดของเซอร์วิสที่เหมาะสม และแปลงผลลัพธ์ของเซอร์วิสหากจำเป็น ไม่ควรทดสอบตรรกะทางธุรกิจของเซอร์วิสซ้ำอีก ตรรกะของเซอร์วิสควรได้รับการครอบคลุมโดย unit tests ของเซอร์วิสอยู่แล้ว Unit tests ของคอนโทรลเลอร์มุ่งเน้นไปที่ความรับผิดชอบเฉพาะของคอนโทรลเลอร์: การกำหนดเส้นทาง การดึงพารามิเตอร์ การเรียกเซอร์วิส และการจัดรูปแบบการตอบสนอง การจำลองเซอร์วิสช่วยให้สามารถทดสอบการโต้ตอบของคอนโทรลเลอร์กับสัญญาของเซอร์วิส (ลายเซ็นเมธอด ประเภทผลลัพธ์ที่คาดหวัง) โดยไม่ต้องดำเนินการตรรกะของเซอร์วิสจริงโมดูลที่ 6: การเขียนโค้ดที่ทดสอบได้ - End-to-End (E2E) Testing6.1. การตั้งค่าสภาพแวดล้อม E2E Testing (Jest & Supertest)E2E tests เป็นการทดสอบแอปพลิเคชันโดยรวม รวมถึงวงจรการร้องขอ/การตอบสนอง HTTP และการโต้ตอบกับฐานข้อมูล (ซึ่งอาจเป็นฐานข้อมูลทดสอบ) Nest CLI จะสร้างโครงสร้างพื้นฐานสำหรับการทดสอบ E2E โดยใช้ Jest และ Supertest โดยอัตโนมัติ ไฟล์ทดสอบ E2E มักจะอยู่ในรูปแบบ *.e2e-spec.tsการตั้งค่า TestingModule สำหรับ E2E tests มักจะเกี่ยวข้องกับการ import AppModule หลัก และใช้ app.getHttpServer() ร่วมกับ supertest เพื่อส่งคำขอ HTTP ไปยังแอปพลิเคชันE2E tests ให้ความมั่นใจในระดับสูงสุดว่าคอมโพเนนต์ต่างๆ ของแอปพลิเคชันทำงานร่วมกันอย่างถูกต้อง เนื่องจากเป็นการจำลองการโต้ตอบของผู้ใช้จริง อย่างไรก็ตาม โดยทั่วไปแล้วจะช้ากว่าและซับซ้อนกว่าในการตั้งค่าและบำรุงรักษาเมื่อเทียบกับ unit tests E2E tests เกี่ยวข้องกับสแต็กแอปพลิเคชันทั้งหมด (เซิร์ฟเวอร์ HTTP, คอนโทรลเลอร์, เซอร์วิส, ฐานข้อมูล) และสามารถจับปัญหาการผสานรวมที่ unit tests อาจพลาดไป การตั้งค่ามักจะต้องมี instance ของแอปพลิเคชันที่ทำงานอยู่และอาจต้องมีฐานข้อมูลทดสอบเฉพาะ เนื่องจากขอบเขตที่กว้าง การทดสอบจึงใช้เวลานานกว่าในการดำเนินการ โดยทั่วไปแล้วจะพยายามสร้างสมดุลระหว่าง unit, integration, และ E2E tests6.2. การสร้าง E2E Tests สำหรับการดำเนินการ Todo CRUDจะมีการเขียน E2E tests สำหรับแต่ละ endpoint ของ Todo API ตัวอย่างเช่น:
สำหรับ POST /todos: ส่งคำขอพร้อม DTO ที่ถูกต้อง, ตรวจสอบสถานะการตอบสนองเป็น 201, ตรวจสอบ body ของการตอบสนอง, และตรวจสอบข้อมูลในฐานข้อมูลทดสอบ
สำหรับ GET /todos: ตรวจสอบสถานะการตอบสนองเป็น 200, ตรวจสอบว่าการตอบสนองเป็นอาร์เรย์, และอาจตรวจสอบรายการที่รู้จัก
การจัดการสถานะฐานข้อมูลสำหรับ E2E tests เป็นสิ่งสำคัญ เช่น การล้างฐานข้อมูลก่อนหรือหลังการทดสอบ หรือการใช้ฐานข้อมูลทดสอบเฉพาะการจัดการสถานะฐานข้อมูลเป็นความท้าทายที่สำคัญในการทดสอบ E2E กลยุทธ์ต่างๆ เช่น การใช้ฐานข้อมูลทดสอบแยกต่างหาก การล้างข้อมูลระหว่างการทดสอบ (เช่น ใน beforeEach หรือ afterEach hooks) หรือการใช้ transaction rollbacks มีความจำเป็นสำหรับการทดสอบ E2E ที่เชื่อถือได้และทำซ้ำได้ E2E tests โต้ตอบกับฐานข้อมูล ดังนั้นสถานะของฐานข้อมูลจึงสามารถส่งผลต่อผลลัพธ์การทดสอบได้ หากการทดสอบหนึ่งทิ้งข้อมูลไว้เบื้องหลัง อาจรบกวนการทดสอบครั้งต่อไป สถานะฐานข้อมูลที่สะอาดและคาดการณ์ได้เป็นสิ่งจำเป็นสำหรับผลลัพธ์การทดสอบที่สอดคล้องกัน เวิร์คชอปควรสาธิตกลยุทธ์พื้นฐานอย่างน้อยหนึ่งอย่างสำหรับเรื่องนี้ (เช่น การล้างตาราง)โมดูลที่ 7: เอกสาร API ด้วย Swagger (OpenAPI)7.1. การผสานรวม Swagger สำหรับเอกสาร API อัตโนมัติOpenAPI Specification เป็นมาตรฐานสำหรับการอธิบาย RESTful APIs และ Swagger UI เป็นเครื่องมือที่แสดงผลข้อกำหนดเหล่านั้นในรูปแบบที่โต้ตอบได้ในการผสานรวม Swagger เข้ากับ NestJS:

ติดตั้ง dependencies: npm install --save @nestjs/swagger swagger-ui-express (เอกสาร กล่าวถึง @scalar/nestjs-api-reference เป็น UI ทางเลือก แต่ swagger-ui-express หรือ fastify-swagger เป็นที่นิยมกว่าเมื่อใช้กับ @nestjs/swagger เอง)


เริ่มต้น Swagger ใน main.ts: ใช้ SwaggerModule และ DocumentBuilder
TypeScript// ใน main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  const config = new DocumentBuilder()
   .setTitle('Todo API')
   .setDescription('API for managing Todo items')
   .setVersion('1.0')
   .addTag('todos') // Optional tag
   .build();
  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api-docs', app, document); // Swagger UI จะอยู่ที่ /api-docs

  await app.listen(process.env.PORT |


| 3000);}bootstrap();```3.  เข้าถึง Swagger UI: เปิดเบราว์เซอร์และไปที่ /api-docs (หรือ path ที่กำหนด) เพื่อดูเอกสาร API@nestjs/swagger ใช้ประโยชน์จาก TypeScript metadata และ decorators เพื่อสร้างข้อกำหนด OpenAPI ส่วนใหญ่โดยอัตโนมัติ ซึ่งช่วยลดความพยายามด้วยตนเองที่จำเป็นสำหรับเอกสาร API ได้อย่างมาก และช่วยให้เอกสารตรงกับโค้ดอยู่เสมอ การเขียนข้อกำหนด OpenAPI ด้วยตนเองนั้นน่าเบื่อและมีโอกาสเกิดข้อผิดพลาดได้ง่าย @nestjs/swagger ตรวจสอบคอนโทรลเลอร์, route decorators (@Get, @Post), DTOs (สำหรับ request/response schemas), และ decorators อื่นๆ เพื่อสร้างข้อกำหนด การทำงานอัตโนมัตินี้หมายความว่าเมื่อโค้ดเปลี่ยนแปลง เอกสารสามารถสร้างขึ้นใหม่ได้อย่างง่ายดายเพื่อสะท้อนการเปลี่ยนแปลงเหล่านั้น7.2. การเพิ่มคำอธิบายประกอบให้กับคอนโทรลเลอร์และ DTOs เพื่อเอกสารที่ชัดเจนใช้ decorators จาก @nestjs/swagger เพื่อเพิ่มรายละเอียดให้กับเอกสาร:
@ApiOperation({ summary: '...' }): สำหรับคำอธิบาย endpoint
@ApiResponse({ status: 200, description: '...', type: TodoDto }): สำหรับรายละเอียดการตอบสนอง
@ApiProperty(): ใน DTOs สำหรับคำอธิบายคุณสมบัติ, ตัวอย่างค่า ฯลฯ (แม้ว่ามักจะถูกอนุมานได้)
@ApiTags(): สำหรับการจัดกลุ่ม endpoints
@ApiBody(): สำหรับคำอธิบาย request body โดยละเอียดหากจำเป็น
decorators เหล่านี้จะช่วยเพิ่มความสมบูรณ์ให้กับ Swagger UI ที่สร้างขึ้น ทำให้ผู้ใช้งานเข้าใจ API ได้ง่ายขึ้นเอกสาร Swagger ที่สมบูรณ์ ซึ่งสร้างขึ้นผ่าน decorators เหล่านี้ ไม่เพียงแต่ทำหน้าที่เป็นข้อมูลอ้างอิงสำหรับผู้บริโภค API เท่านั้น แต่ยังเป็นเครื่องมือที่มีค่าสำหรับนักพัฒนา frontend และผู้ทดสอบ ช่วยให้พวกเขาเข้าใจและโต้ตอบกับ API ได้อย่างมีประสิทธิภาพ API ที่มีเอกสารที่ดีช่วยลดความคลุมเครือและคำถาม Swagger UI เป็นวิธีการโต้ตอบในการลองใช้ API endpoints ทีม frontend สามารถใช้ข้อกำหนดเพื่อจำลองการเรียก API หรือทำความเข้าใจโครงสร้างข้อมูล ผู้ทดสอบสามารถใช้เพื่อออกแบบกรณีทดสอบส่วนที่ 4: การดำเนินการฐานข้อมูลขั้นสูงและสรุปเวิร์คชอปโมดูลที่ 8: การสาธิตความสามารถในการพกพาฐานข้อมูล - การเปลี่ยนไปใช้ PostgreSQL8.1. เหตุผลในการเปลี่ยนฐานข้อมูลมีหลายสาเหตุที่อาจทำให้ต้องเปลี่ยนฐานข้อมูล เช่น ความต้องการด้านความสามารถในการขยายขนาด (scalability), คุณสมบัติเฉพาะของ PostgreSQL (เช่น การสนับสนุน JSON ขั้นสูง, ความสามารถด้านภูมิสารสนเทศ, ความสมบูรณ์ของข้อมูลที่เข้มงวดกว่า)การเปรียบเทียบสั้นๆ ระหว่าง SQLite (ฐานข้อมูลแบบไฟล์, เหมาะสำหรับการพัฒนาและแอปพลิเคชันง่ายๆ) กับ PostgreSQL (ฐานข้อมูลแบบเซิร์ฟเวอร์, แข็งแกร่ง, มีคุณสมบัติหลากหลาย, เหมาะสำหรับ production) จะช่วยให้เห็นภาพชัดเจนขึ้นความสามารถในการสับเปลี่ยนฐานข้อมูลได้อย่างค่อนข้างง่าย (ต้องขอบคุณ ORMs เช่น TypeORM) เป็นข้อได้เปรียบทางสถาปัตยกรรมที่สำคัญ ช่วยให้โปรเจกต์สามารถเริ่มต้นอย่างง่ายและพัฒนา backend ฐานข้อมูลของตนเมื่อความต้องการเติบโตขึ้น โดยไม่จำเป็นต้องเขียนชั้นการเข้าถึงข้อมูลใหม่ทั้งหมด โปรเจกต์ในระยะเริ่มต้นอาจให้ความสำคัญกับความเร็วในการพัฒนาและความเรียบง่าย (SQLite) เมื่อปริมาณการใช้งานและความซับซ้อนของข้อมูลเพิ่มขึ้น อาจจำเป็นต้องใช้ฐานข้อมูลที่แข็งแกร่งกว่า (PostgreSQL) ORMs สรุปรายละเอียด SQL เฉพาะฐานข้อมูลจำนวนมาก ทำให้โค้ดชั้นเซอร์วิสส่วนใหญ่สามารถพกพาได้ การเปลี่ยนแปลงหลักๆ อยู่ที่การกำหนดค่าและอาจมีการจัดการคุณสมบัติเฉพาะของฐานข้อมูลหากมีการใช้งานโดยตรง8.2. การติดตั้งไดรเวอร์ PostgreSQL และการกำหนดค่า TypeORM ใหม่

ติดตั้งไดรเวอร์ PostgreSQL: npm install pg


อัปเดตการกำหนดค่า TypeOrmModule.forRoot() สำหรับ PostgreSQL:
TypeScript// ใน app.module.ts หรือโมดูลฐานข้อมูลที่แยกต่างหาก
TypeOrmModule.forRoot({
  type: 'postgres',
  host: process.env.DB_HOST |


| 'localhost',port: parseInt(process.env.DB_PORT, 10) || 5432,username: process.env.DB_USERNAME || 'postgres_user',password: process.env.DB_PASSWORD || 'postgres_password',database: process.env.DB_NAME || 'todo_app_pg',entities: [__dirname + '/../**/.entity{.ts,.js}'],synchronize: false, // สำคัญ: ตั้งค่าเป็น false สำหรับ production/PostgreSQL// migrations: [__dirname + '/../migrations/{.ts,.js}'], // Path to migrations// cli: { migrationsDir: 'src/migrations' }}),```อธิบายพารามิเตอร์การเชื่อมต่อใหม่/ที่เปลี่ยนแปลง (host, port, username, password, database) และเน้นย้ำการตั้งค่า synchronize: false 7การสับเปลี่ยนฐานข้อมูลใน TypeORM ส่วนใหญ่เกี่ยวข้องกับการเปลี่ยนแปลง type และพารามิเตอร์เฉพาะการเชื่อมต่อ คำจำกัดความของ entity และการใช้ repository ในเซอร์วิสมักจะไม่เปลี่ยนแปลงหากไม่มีการใช้คุณสมบัติเฉพาะของฐานข้อมูล TypeORM สรุปภาษา SQL พื้นฐานสำหรับการดำเนินการทั่วไป decorators @Entity, @Column ฯลฯ ไม่ขึ้นอยู่กับฐานข้อมูลสำหรับคุณสมบัติมาตรฐาน ชั้นเซอร์วิสโต้ตอบกับ TypeORM Repository API ซึ่งสอดคล้องกันในฐานข้อมูลที่รองรับตาราง: การกำหนดค่า TypeORM: SQLite เทียบกับ PostgreSQLตารางนี้จะช่วยให้ผู้เข้าร่วมเวิร์คชอปเห็นภาพการเปลี่ยนแปลงที่จำเป็นในการกำหนดค่า TypeOrmModule.forRoot() อย่างชัดเจนเมื่อทำการสลับฐานข้อมูล และตอกย้ำความแตกต่างที่สำคัญในการจัดการ synchronize และการนำ migrations มาใช้สำหรับ PostgreSQLพารามิเตอร์ตัวอย่าง SQLiteตัวอย่าง PostgreSQLหมายเหตุtype'sqlite''postgres'ระบุไดรเวอร์ฐานข้อมูลdatabase'db.sqlite''your_pg_database'Path ไฟล์สำหรับ SQLite, ชื่อฐานข้อมูลสำหรับ PostgreSQLhostN/A'localhost' หรือ process.env.DB_HOSTโฮสต์เซิร์ฟเวอร์ PostgreSQLportN/A5432 หรือ process.env.DB_PORTพอร์ตเซิร์ฟเวอร์ PostgreSQLusernameN/A'your_user' หรือ process.env.DB_USERชื่อผู้ใช้ PostgreSQLpasswordN/A'your_pass' หรือ process.env.DB_PASSรหัสผ่าน PostgreSQLentities`` หรือ path glob`` หรือ path globเหมือนกันทั้งคู่synchronizetrue (dev)false (แนะนำสำหรับ PG, ใช้ migrations)ความแตกต่างที่สำคัญ true เสี่ยงสำหรับ productionmigrationsพบน้อยกว่า แต่เป็นไปได้['dist/migrations/*.js'] (ตัวอย่าง)จำเป็นสำหรับ PostgreSQL ใน productionmigrationsRunfalsetrue (ทางเลือก, เพื่อรันเมื่อเริ่มต้น)กำหนดว่าจะรัน migrations โดยอัตโนมัติเมื่อแอปพลิเคชันเริ่มต้นหรือไม่8.3. การจัดการความแตกต่างของสกีมา: Synchronization และ Migrationsย้ำอีกครั้งว่าเหตุใด synchronize: true จึงไม่เหมาะสำหรับสภาพแวดล้อม production และแนะนำ TypeORM migrations ว่าเป็นวิธีการจัดการการเปลี่ยนแปลงสกีมาฐานข้อมูลแบบควบคุมและมีเวอร์ชันแสดงวิธีการสร้าง migration: typeorm migration:generate -n CreateTodoSchema (หรือใช้ npm scripts จาก) จากนั้นตรวจสอบไฟล์ migration ที่สร้างขึ้น (ซึ่งจะมีคำสั่ง SQL สำหรับสร้างตาราง) และรัน migration: typeorm migration:run (หรือ npm script)กล่าวถึงกลยุทธ์การย้ายข้อมูล (data migration) สั้นๆ (เนื่องจากการย้ายข้อมูลเต็มรูปแบบมีความซับซ้อน) สามารถกล่าวถึงเครื่องมือเช่น pgloader สำหรับการย้ายข้อมูลที่มีอยู่จาก SQLite ไปยัง PostgreSQL สำหรับเวิร์คชอปนี้ จะเน้นที่การสร้างสกีมาในฐานข้อมูล PostgreSQL ที่ว่างเปล่าผ่าน migrationsTypeORM migrations เป็นวิธีการเขียนโปรแกรมและควบคุมเวอร์ชันในการพัฒนาสกีมาฐานข้อมูล ซึ่งจำเป็นสำหรับการทำงานร่วมกันในทีมและการปรับใช้แอปพลิเคชันไปยังสภาพแวดล้อมต่างๆ (dev, staging, prod) การเปลี่ยนแปลงสกีมาด้วยตนเองมีโอกาสเกิดข้อผิดพลาดและติดตามได้ยาก Migrations เป็นโค้ดและสามารถ commit เข้าสู่ระบบควบคุมเวอร์ชันได้ แต่ละ migration มีเมธอด up และ down ทำให้สามารถใช้และย้อนกลับการเปลี่ยนแปลงสกีมาได้ สิ่งนี้ทำให้มั่นใจได้ว่าทุกสภาพแวดล้อมมีสกีมาที่สอดคล้องกันในขณะที่ TypeORM migrations จัดการสกีมา การย้าย ข้อมูล ระหว่างระบบฐานข้อมูลที่แตกต่างกัน (เช่น SQLite ไป PostgreSQL) เป็นความท้าทายที่แยกต่างหากและมักจะซับซ้อนกว่า เวิร์คชอปควรชี้แจงความแตกต่างนี้ให้ชัดเจน สำหรับขอบเขตของเวิร์คชอป การสร้างสกีมาใน PostgreSQL ผ่าน migrations และเริ่มต้นด้วยข้อมูลใหม่นั้นยอมรับได้ migration:generate ของ TypeORM สร้างสกีมาตาม entities ไม่ได้ย้ายข้อมูล การย้ายข้อมูลเกี่ยวข้องกับการดึงข้อมูลจากแหล่งที่มา (SQLite) การแปลงข้อมูลหากจำเป็น (ความแตกต่างของประเภทข้อมูล ฯลฯ) และการโหลดข้อมูลเข้าสู่เป้าหมาย (PostgreSQL) เครื่องมือเช่น pgloader ออกแบบมาสำหรับการเคลื่อนย้ายข้อมูลนี้ แต่อยู่นอกขอบเขตของการย้ายสกีมา TypeORM พื้นฐาน การรับทราบความซับซ้อนนี้เป็นการตั้งความคาดหวังที่เป็นจริง8.4. การตรวจสอบการทำงานของแอปพลิเคชันกับ PostgreSQLตรวจสอบให้แน่ใจว่าเซิร์ฟเวอร์ฐานข้อมูล PostgreSQL ทำงานและสามารถเข้าถึงได้ จากนั้นเริ่มแอปพลิเคชัน NestJS ด้วยการกำหนดค่า PostgreSQL ใหม่ และทดสอบการดำเนินการ CRUD ทั้งหมดสำหรับ Todo API อีกครั้ง (โดยใช้ Postman/Insomnia หรือ E2E tests) เพื่อยืนยันว่าทำงานได้อย่างถูกต้องกับ PostgreSQLขั้นตอนนี้เป็นการตรวจสอบที่สำคัญ หากแอปพลิเคชันทำงานกับ PostgreSQL ได้เช่นเดียวกับที่ทำงานกับ SQLite (สำหรับคุณสมบัติที่กำหนดไว้) นั่นแสดงให้เห็นถึงประสิทธิภาพของการสรุปของ ORM และการสับเปลี่ยนฐานข้อมูลที่ประสบความสำเร็จ เป้าหมายของการใช้ ORM ส่วนหนึ่งคือเพื่อให้เกิดความเป็นอิสระจากฐานข้อมูลสำหรับการดำเนินการทั่วไป การรันตรรกะแอปพลิเคชันเดียวกันกับฐานข้อมูลที่แตกต่างกันได้สำเร็จเป็นการตรวจสอบสิ่งนี้ นอกจากนี้ยังช่วยจับปัญหาเล็กน้อยที่อาจเกิดขึ้นจากพฤติกรรมเฉพาะของฐานข้อมูลหากไม่ได้รับการสรุปอย่างเหมาะสมโมดูลที่ 9: สรุปเวิร์คชอปและการเรียนรู้เพิ่มเติม9.1. สรุปประเด็นสำคัญและแนวทางปฏิบัติที่ดีที่สุดสรุปแนวคิดหลักของ NestJS ที่ได้เรียนรู้ (modules, controllers, services, DI) และย้ำแนวทางปฏิบัติที่ดีที่สุด เช่น การใช้ DTOs สำหรับการตรวจสอบความถูกต้อง, Repository Pattern, การทดสอบที่ครอบคลุม, เอกสาร API, และ migrations สำหรับการจัดการสกีมา เน้นประโยชน์ของความสามารถในการทดสอบและความยืดหยุ่นของฐานข้อมูลเวิร์คชอปนี้สาธิตวงจรชีวิตการพัฒนาแบบ end-to-end ตั้งแต่การเริ่มต้นโปรเจกต์ไปจนถึงการพิจารณาการปรับใช้ เช่น การเลือกฐานข้อมูลและการจัดการสกีมา ทั้งหมดนี้อยู่ในบริบทของเฟรมเวิร์กที่ทันสมัยและแข็งแกร่ง ซึ่งเป็นการวางรากฐานที่มั่นคงสำหรับการสร้างแอปพลิเคชันในโลกแห่งความเป็นจริง9.2. หัวข้อขั้นสูงของ NestJS และแหล่งข้อมูลสำหรับการเรียนรู้เพิ่มเติมแนะนำหัวข้อขั้นสูงสำหรับผู้ที่ต้องการศึกษา NestJS ต่อไป เช่น:
Authentication & Authorization (เช่น การใช้ Passport.js)
GraphQL
WebSockets
Microservices
Configuration Management
Logging
Interceptors, Guards, Pipes (การใช้งานขั้นสูง)
Caching
Task Scheduling
Queues
ชี้ไปยังเอกสารอย่างเป็นทางการของ NestJS และแหล่งข้อมูลชุมชนอื่นๆการรับทราบว่าเวิร์คชอปนี้เป็นจุดเริ่มต้นจะกระตุ้นให้เกิดการเรียนรู้อย่างต่อเนื่องและการสำรวจระบบนิเวศที่สมบูรณ์ของ NestJS ซึ่งเป็นการเตรียมผู้เข้าร่วมให้พร้อมสำหรับความท้าทายที่ซับซ้อนยิ่งขึ้นสรุปแผนการเวิร์คชอปนี้ได้รับการออกแบบมาเพื่อให้ผู้เข้าร่วมมีความเข้าใจอย่างลึกซึ้งเกี่ยวกับการพัฒนาแอปพลิเคชันด้วย NestJS โดยเน้นที่การสร้างโค้ดที่มีคุณภาพสูง ทดสอบได้ง่าย และสามารถบำรุงรักษาได้ในระยะยาว การครอบคลุมตั้งแต่แนวคิดพื้นฐาน การออกแบบ API การผสานรวมฐานข้อมูลด้วย TypeORM (ทั้ง SQLite และ PostgreSQL) ไปจนถึงการทดสอบที่ครอบคลุม (Unit และ E2E) และการสร้างเอกสาร API อัตโนมัติด้วย Swagger จะช่วยให้ผู้เข้าร่วมมีความพร้อมในการนำความรู้ไปประยุกต์ใช้ในการสร้างแอปพลิเคชันจริงประเด็นสำคัญของเวิร์คชอปนี้คือการสาธิตความยืดหยุ่นในการจัดการฐานข้อมูล ซึ่งเป็นทักษะที่มีค่าในโลกการพัฒนาซอฟต์แวร์ที่เปลี่ยนแปลงอยู่เสมอ การทำความเข้าใจวิธีการสลับระหว่างฐานข้อมูลต่างๆ โดยใช้ ORM และการจัดการการเปลี่ยนแปลงสกีมาผ่าน migrations จะช่วยให้นักพัฒนาสามารถปรับตัวเข้ากับความต้องการที่เปลี่ยนแปลงไปของโปรเจกต์ได้ดียิ่งขึ้นท้ายที่สุด ผู้เข้าร่วมไม่เพียงแต่จะได้เรียนรู้วิธีการสร้างแอปพลิเคชัน Todo ที่ทำงานได้ แต่ยังได้ซึมซับแนวทางปฏิบัติที่ดีที่สุดซึ่งเป็นรากฐานสำคัญของการเป็นนักพัฒนาซอฟต์แวร์ที่มีประสิทธิภาพและสามารถสร้างโซลูชันที่แข็งแกร่งและยั่งยืนได้.